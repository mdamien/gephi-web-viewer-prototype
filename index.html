<script src="static/jquery.js" ></script>
<script src="static/sigma.js" ></script>
<script src="static/plugins.js" ></script>
<div>
  <style>
    #graph-container {
      top: 0;
      bottom: 0;
      left: 0;
      right: 0;
      position: absolute;
      background: #eee;
    }
    #infopane {
      top: 0;
      bottom: 0;
      right: 0;
      position: absolute;
      width: 230px;
      display: none;
      padding: 10px;
      background-color: rgb(249, 247, 237);
      box-shadow: 0 2px 6px rgba(0,0,0,0.3);
    }
    #infopane > div {
      margin: 10px;
      overflow-x: auto;
    }
  </style>
  <div id="graph-container"></div>
  <div id="infopane">
    <h2 id="ip-node-name"></h2>
    <pre id="ip-infos"></pre>
  </div>

</div>
<script>

function parseJSON(data) {
  var g = {
    nodes: [],
    edges: []
  };

  for (i=0; i<data.nodes.length; i++){
    var node = data.nodes[i];
    // s.addNode(id,data.nodes[i]);

    g.nodes.push({
      id: node.id,
      label: node.label,
      x: node.x,
      y: node.y,
      size: node.size + 3,
      color: node.color,
      attributes: node.attributes,
    });
  }

  for(j=0; j<data.edges.length; j++){
    var edge = data.edges[j];

    g.edges.push({
      id: edge.id,
      source: edge.source,
      target: edge.target,
      size: edge.size,
      color: edge.color,
      type: 'curve',
    });
  }

  return g;
}

function nodeByID(s, id) {
  return s.graph.nodes().filter(node => node['id'] === id).pop();
}

function getNodeInfos(s, e) {
  var attributes = e.data.node.attributes;
  var attributes_text = '';

  for (attribute in attributes) {
    var value = attributes[attribute];
    attributes_text += attribute + ': '+ value + '\n'
  }

  if (attributes_text) {
    attributes_text += '\n\n'
  }

  return attributes_text + getNodeLinkInfos(s, e);
}

function getNodeLinkInfos(s, e) {
    var incoming = [];
    var outcoming = [];

    s.graph.edges().forEach(function(edge) {
      if (edge.source == e.data.node.id) {
        outcoming.push(nodeByID(s, edge.target).id);
      }
      else if (edge.target == e.data.node.id) {
        incoming.push(nodeByID(s, edge.source).id);
      }
    })

    var incoming_filtered = [];
    var outcoming_filtered = [];
    var mutual = [];
    incoming.forEach(function(node) {
      if (outcoming.indexOf(node) === -1) {
        incoming_filtered.push(node)
      } else {
        mutual.push(node)
      }
    });
    outcoming.forEach(function(node) {
      if (incoming.indexOf(node) === -1) {
        outcoming_filtered.push(node)
      }
    });

    incoming = incoming_filtered.map(node => nodeByID(s, node).label)
    outcoming = outcoming_filtered.map(node => nodeByID(s, node).label)
    mutual = mutual.map(node => nodeByID(s, node).label)

    if (mutual.length) {
      mutual = 'Mutal links:\n' + mutual.join('\n') + '\n\n';
    }
    if (incoming.length) {
      incoming = 'Incoming links:\n' + incoming.join('\n') + '\n\n';
    }
    if (outcoming.length) {
      outcoming = 'Outcoming link:\n' + outcoming.join('\n') + '\n\n';
    }
    return 'Connections:\n\n'mutual + incoming + outcoming
}

$.getJSON('data.json', function (data) {
  var g = parseJSON(data);

  var s = new sigma({
    graph: g, 
    renderer: {
      container: 'graph-container',
      type: sigma.renderers.canvas,
    },
    settings: {
      hideEdgesOnMove: true,
      maxNodeSize: 10,
      minNodeSize: 0.00001,
      autoRescale: false,
    },
  });

  s.camera.goTo({
    x: 0,
    y: 0,
    angle: 0,
    ratio: 3
  });

  var filter = new sigma.plugins.filter(s);

  s.bind('clickNode', function(e) {
    filter.undo()
    filter.neighborsOf(e.data.node.id).apply();

    $('#infopane').show()
    $('#ip-node-name').text(e.data.node.label)

    $('#ip-infos').text(getNodeInfos(s, e))
  });

  s.bind('clickStage', function(e) {
    filter.undo().apply();
    $('#infopane').hide();
  });
});
</script>